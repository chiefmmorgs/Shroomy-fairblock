<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shroomy Sticker Editor - Fixed</title>

  <!-- React / Konva CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/konva@9.7.8/konva.min.js"></script>
  <script src="https://unpkg.com/react-konva@18.2.10/umd/react-konva.min.js"></script>

  <style>
    /* Keep your style from the original file (kept minimal here) */
    body { font-family: Arial, Helvetica, sans-serif; margin: 0; padding: 20px; background: #f5f0f8; }
    .app-container { max-width: 1200px; margin: 0 auto; }
    .panel { background: white; border: 3px solid #333; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
    .sticker-palette { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
    .sticker-item { aspect-ratio: 1; border-radius: 50%; border: 3px solid #333; background: white; cursor: pointer; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .canvas-wrapper { border: 6px solid #333; border-radius: 12px; padding: 8px; display:inline-block; background:white; }
    .btn { padding: 8px 12px; border-radius: 8px; border: 2px solid #333; background:white; cursor:pointer; }
    .top-bar { display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; }
    .controls { margin-top:12px; }
  </style>
</head>
<body>
  <div id="root" class="app-container"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;
    const { Stage, Layer, Image: KonvaImage, Transformer, Rect, Text: KonvaText } = window.ReactKonva;

    // Config - filenames match your folder
    const STICKER_FILES = [
      '1.png','2.png','3.png','4.png','5.png','6.png','7.png','8.png','9.png','10.png',
      '11.png','12.png','13.png','14.png','15.png','16.png','17.png','18.png','19.png','20.png',
      '21.png','22.png','23.png','24.png','25.png','26.png','image.png'
    ];
    const STICKER_BASE_PATH = './stickers/';

    const DEFAULT_STICKERS = STICKER_FILES.map(f => ({
      src: STICKER_BASE_PATH + f,
      name: f
    }));

    const EMOJI_STICKERS = ['🍄','🌟','✨','💜','🎨','🌈','🦋','🌸','🍀','⭐','💫','🌙'];

    function App(){
      const [photo, setPhoto] = useState(null);
      const [photoImage, setPhotoImage] = useState(null);
      const [stickers, setStickers] = useState([]);
      const [selectedId, setSelectedId] = useState(null);
      const [customStickers, setCustomStickers] = useState([]);
      const [toast, setToast] = useState(null);
      const [canvasSize, setCanvasSize] = useState({ width: 600, height: 600 });

      const stageRef = useRef(null);
      const fileInputRef = useRef(null);
      const customStickerInputRef = useRef(null);
      const transformerRef = useRef(null);

      // Toast
      const showToast = (m) => { setToast(m); setTimeout(()=>setToast(null),2500); };

      // Handle photo upload
      const handlePhotoUpload = (file) => {
        if (!file) return;
        if (!file.type.startsWith('image/')) { showToast('Upload an image'); return; }
        if (file.size > 10 * 1024 * 1024) { showToast('Max 10MB'); return; }

        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new window.Image();
          img.onload = () => {
            const maxSize = 600;
            let w = img.width, h = img.height;
            if (w > maxSize || h > maxSize) {
              if (w > h) { h = (h / w) * maxSize; w = maxSize; }
              else { w = (w / h) * maxSize; h = maxSize; }
            }
            setCanvasSize({ width: w, height: h });
            setPhotoImage(img);
            setPhoto({
              src: e.target.result,
              originalWidth: img.width,
              originalHeight: img.height,
              displayWidth: w,
              displayHeight: h
            });
            showToast('Photo uploaded');
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      };

      // Add sticker
      // isImage true -> treat content as image URL/data
      const addSticker = (content, isImage = true) => {
        if (!photo) { showToast('Upload a photo first'); return; }
        const newSticker = {
          id: Date.now() + Math.random(),
          content,
          isImage,
          x: canvasSize.width / 2,
          y: canvasSize.height / 2,
          width: isImage ? 100 : 60,
          height: isImage ? 100 : 60,
          rotation: 0,
          opacity: 1,
          scaleX: 1,
          scaleY: 1,
          flipX: false,
          flipY: false
        };
        const ns = [...stickers, newSticker];
        setStickers(ns);
        setSelectedId(newSticker.id);
        showToast('Sticker added');
      };

      // Custom sticker upload
      const handleCustomStickerUpload = (file) => {
        if (!file || !file.type.startsWith('image/')) return;
        if (file.size > 5 * 1024 * 1024) { showToast('Sticker too large (max 5MB)'); return; }
        const reader = new FileReader();
        reader.onload = (e) => {
          setCustomStickers(prev => [...prev, e.target.result]);
          showToast('Custom sticker added');
        };
        reader.readAsDataURL(file);
      };

      // Controls from right panel: update selected sticker
      const updateSticker = (updates) => {
        if (!selectedId) return;
        setStickers(prev => {
          const ns = prev.map(s => s.id === selectedId ? { ...s, ...updates } : s);
          return ns;
        });
      };

      const deleteSticker = () => {
        if (!selectedId) return;
        setStickers(prev => prev.filter(s => s.id !== selectedId));
        setSelectedId(null);
        showToast('Sticker removed');
      };

      const duplicateSticker = () => {
        const s = stickers.find(s => s.id === selectedId);
        if (!s) return;
        const copy = { ...s, id: Date.now() + Math.random(), x: s.x + 20, y: s.y + 20 };
        setStickers(prev => [...prev, copy]);
        setSelectedId(copy.id);
        showToast('Duplicated');
      };

      // Reorder layers
      const moveLayer = (dir) => {
        const idx = stickers.findIndex(s => s.id === selectedId);
        if (idx === -1) return;
        setStickers(prev => {
          const arr = [...prev];
          if (dir === 'up' && idx < arr.length - 1) {
            [arr[idx], arr[idx+1]] = [arr[idx+1], arr[idx]];
          } else if (dir === 'down' && idx > 0) {
            [arr[idx], arr[idx-1]] = [arr[idx-1], arr[idx]];
          } else if (dir === 'top') {
            const [item] = arr.splice(idx,1); arr.push(item);
          } else if (dir === 'bottom') {
            const [item] = arr.splice(idx,1); arr.unshift(item);
          }
          return arr;
        });
      };

      // Download/export - ensure all sticker images load first
      const downloadImage = async () => {
        if (!photo) { showToast('Upload photo first'); return; }

        // ensure all image stickers are loaded
        await Promise.all(stickers.filter(s => s.isImage).map(s => {
          return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve();
            img.onerror = () => resolve(); // proceed even if one fails
            img.src = s.content;
          });
        }));

        const originalStage = new window.Konva.Stage({
          container: document.createElement('div'),
          width: photo.originalWidth,
          height: photo.originalHeight
        });
        const layer = new window.Konva.Layer();
        originalStage.add(layer);

        // background image scaled to original size
        const bg = new window.Konva.Image({
          image: photoImage,
          x: 0,
          y: 0,
          width: photo.originalWidth,
          height: photo.originalHeight
        });
        layer.add(bg);

        const scaleX = photo.originalWidth / canvasSize.width;
        const scaleY = photo.originalHeight / canvasSize.height;

        for (const s of stickers) {
          if (s.isImage) {
            const img = new Image();
            img.src = s.content;
            await new Promise(resolve => {
              img.onload = () => {
                const kimg = new window.Konva.Image({
                  image: img,
                  x: s.x * scaleX,
                  y: s.y * scaleY,
                  width: s.width * scaleX,
                  height: s.height * scaleY,
                  rotation: s.rotation,
                  opacity: s.opacity,
                  offsetX: (s.width * scaleX) / 2,
                  offsetY: (s.height * scaleY) / 2,
                  scaleX: s.scaleX * (s.flipX ? -1 : 1),
                  scaleY: s.scaleY * (s.flipY ? -1 : 1)
                });
                layer.add(kimg);
                resolve();
              };
              img.onerror = () => resolve();
            });
          } else {
            const text = new window.Konva.Text({
              text: s.content,
              x: s.x * scaleX,
              y: s.y * scaleY,
              fontSize: s.width * scaleX,
              rotation: s.rotation,
              opacity: s.opacity,
              offsetX: (s.width * scaleX) / 2,
              offsetY: (s.height * scaleY) / 2,
              scaleX: s.scaleX * (s.flipX ? -1 : 1),
              scaleY: s.scaleY * (s.flipY ? -1 : 1)
            });
            layer.add(text);
          }
        }

        layer.draw();
        originalStage.toBlob({
          callback: (blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'shroomy-creation.png';
            a.click();
            URL.revokeObjectURL(url);
            originalStage.destroy();
            showToast('Downloaded');
          },
          pixelRatio: 2
        });
      };

      return (
        <div>
          <div className="top-bar">
            <button className="btn" onClick={() => fileInputRef.current?.click()}>Upload Photo</button>
            <button className="btn" onClick={downloadImage} disabled={!photo}>Download PNG</button>
            <button className="btn" onClick={() => { setStickers([]); setSelectedId(null); showToast('Reset'); }}>Reset</button>
          </div>

          <div style={{ display: 'flex', gap: 16, alignItems: 'flex-start' }}>
            <div style={{ width: 280 }}>
              <div className="panel">
                <h3>Stickers</h3>
                <div className="sticker-palette" style={{ marginBottom: 8 }}>
                  {DEFAULT_STICKERS.map((st, i) => (
                    <div key={i} className="sticker-item" title={st.name}
                         onClick={() => addSticker(st.src, true)}
                         style={{ backgroundImage: `url(${st.src})`, backgroundSize: 'cover', backgroundPosition: 'center' }}>
                    </div>
                  ))}
                  {EMOJI_STICKERS.map((e,i) => (
                    <div key={'e'+i} className="sticker-item" onClick={() => addSticker(e,false)}>
                      <div style={{ fontSize: 26 }}>{e}</div>
                    </div>
                  ))}
                  {customStickers.map((src,i) => (
                    <div key={'c'+i} className="sticker-item" onClick={() => addSticker(src,true)} style={{ backgroundImage: `url(${src})`, backgroundSize:'cover', backgroundPosition:'center' }}></div>
                  ))}
                </div>

                <div style={{ display:'flex', gap:8 }}>
                  <button className="btn" onClick={() => customStickerInputRef.current?.click()}>Upload Sticker</button>
                  <input ref={customStickerInputRef} type="file" accept="image/*" style={{ display:'none' }} onChange={(e)=>handleCustomStickerUpload(e.target.files[0])}/>
                </div>
              </div>

              <div className="panel controls">
                <h3>Selected</h3>
                {selectedId ? (
                  <>
                    <div style={{ marginBottom:8 }}>
                      <label>X: </label>
                      <input type="number" value={Math.round((stickers.find(s=>s.id===selectedId)||{}).x||0)} onChange={(e)=>updateSticker({ x: parseFloat(e.target.value) || 0 })}/>
                    </div>
                    <div style={{ marginBottom:8 }}>
                      <label>Y: </label>
                      <input type="number" value={Math.round((stickers.find(s=>s.id===selectedId)||{}).y||0)} onChange={(e)=>updateSticker({ y: parseFloat(e.target.value) || 0 })}/>
                    </div>
                    <div style={{ display:'flex', gap:8 }}>
                      <button className="btn" onClick={duplicateSticker}>Duplicate</button>
                      <button className="btn" onClick={deleteSticker}>Delete</button>
                    </div>
                    <div style={{ marginTop:8, display:'flex', gap:8 }}>
                      <button className="btn" onClick={()=>moveLayer('up')}>Forward</button>
                      <button className="btn" onClick={()=>moveLayer('down')}>Backward</button>
                      <button className="btn" onClick={()=>moveLayer('top')}>To Top</button>
                      <button className="btn" onClick={()=>moveLayer('bottom')}>To Bottom</button>
                    </div>
                  </>
                ) : (
                  <div>Select a sticker on the canvas</div>
                )}
              </div>
            </div>

            <div className="panel" style={{ flex: 1 }}>
              <div className="canvas-wrapper">
                {photo ? (
                  <CanvasEditor
                    stageRef={stageRef}
                    transformerRef={transformerRef}
                    photo={photo}
                    photoImage={photoImage}
                    stickers={stickers}
                    setStickers={setStickers}
                    selectedId={selectedId}
                    setSelectedId={setSelectedId}
                    canvasSize={canvasSize}
                  />
                ) : (
                  <div style={{ textAlign:'center', padding:40 }}>Upload an image to start</div>
                )}
              </div>
            </div>

            <div style={{ width: 260 }}>
              <div className="panel">
                <h3>Upload Photo</h3>
                <div style={{ marginBottom:8 }}>
                  <input ref={fileInputRef} type="file" accept="image/*" style={{ display:'none' }} onChange={(e)=>handlePhotoUpload(e.target.files[0])}/>
                  <button className="btn" onClick={()=>fileInputRef.current?.click()}>Choose photo</button>
                </div>
                <div>
                  <small>Display: {Math.round(canvasSize.width)} × {Math.round(canvasSize.height)}</small>
                </div>
              </div>
            </div>
          </div>

          {toast && <div style={{ position:'fixed', right:20, bottom:20, background:'#333', color:'#fff', padding:'10px 14px', borderRadius:8 }}>{toast}</div>}
        </div>
      );
    }

    function CanvasEditor({
      stageRef,
      transformerRef,
      photo,
      photoImage,
      stickers,
      setStickers,
      selectedId,
      setSelectedId,
      canvasSize
    }) {
      const layerRef = useRef(null);
      const [imagesMap, setImagesMap] = useState({});

      // Load image objects for any sticker with isImage
      useEffect(() => {
        let mounted = true;
        (async () => {
          const toLoad = stickers.filter(s => s.isImage && !imagesMap[s.id]);
          if (toLoad.length === 0) return;
          const newMap = {};
          await Promise.all(toLoad.map(s => {
            return new Promise(resolve => {
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = () => {
                newMap[s.id] = img;
                resolve();
              };
              img.onerror = () => resolve();
              img.src = s.content;
            });
          }));
          if (mounted && Object.keys(newMap).length) {
            setImagesMap(prev => ({ ...prev, ...newMap }));
          }
        })();
        return () => { mounted = false; };
      }, [stickers]);

      // Ensure transformer attaches to selected node
      useEffect(() => {
        if (!transformerRef.current) return;
        if (!selectedId) {
          transformerRef.current.nodes([]);
          transformerRef.current.getLayer() && transformerRef.current.getLayer().batchDraw();
          return;
        }
        const selNode = stageRef.current && stageRef.current.findOne(`#sticker-${selectedId}`);
        if (selNode) {
          transformerRef.current.nodes([selNode]);
          transformerRef.current.getLayer() && transformerRef.current.getLayer().batchDraw();
        }
      }, [selectedId, stickers]);

      const handleStageClick = (e) => {
        // click on empty area -> deselect
        if (e.target === e.target.getStage()) {
          setSelectedId(null);
        }
      };

      const onDragEnd = (id, e) => {
        const { x, y } = e.target;
        setStickers(prev => prev.map(s => s.id === id ? { ...s, x, y } : s));
      };

      const onTransformEnd = (id, e) => {
        const node = e.target;
        const scaleX = node.scaleX();
        const scaleY = node.scaleY();
        const w = Math.max(10, node.width() * Math.abs(scaleX));
        const h = Math.max(10, node.height() * Math.abs(scaleY));
        setStickers(prev => prev.map(s => s.id === id ? {
          ...s,
          x: node.x(),
          y: node.y(),
          rotation: node.rotation(),
          scaleX: scaleX,
          scaleY: scaleY,
          width: w,
          height: h
        } : s));
      };

      return (
        <Stage ref={stageRef} width={canvasSize.width} height={canvasSize.height} onMouseDown={handleStageClick} onTouchStart={handleStageClick}>
          <Layer ref={layerRef}>
            {photoImage && (
              <KonvaImage image={photoImage} x={0} y={0} width={canvasSize.width} height={canvasSize.height} />
            )}

            {stickers.map(s => {
              if (s.isImage) {
                const imgObj = imagesMap[s.id];
                if (!imgObj) {
                  // not loaded yet - skip rendering until loaded
                  return null;
                }
                return (
                  <KonvaImage
                    key={s.id}
                    id={`sticker-${s.id}`}
                    image={imgObj}
                    x={s.x}
                    y={s.y}
                    width={s.width}
                    height={s.height}
                    rotation={s.rotation}
                    opacity={s.opacity}
                    offsetX={s.width / 2}
                    offsetY={s.height / 2}
                    scaleX={s.scaleX * (s.flipX ? -1 : 1)}
                    scaleY={s.scaleY * (s.flipY ? -1 : 1)}
                    draggable
                    onClick={() => setSelectedId(s.id)}
                    onTap={() => setSelectedId(s.id)}
                    onDragEnd={(e) => onDragEnd(s.id, e)}
                    onTransformEnd={(e) => onTransformEnd(s.id, e)}
                  />
                );
              } else {
                return (
                  <KonvaText
                    key={s.id}
                    id={`sticker-${s.id}`}
                    text={s.content}
                    x={s.x}
                    y={s.y}
                    fontSize={s.width}
                    rotation={s.rotation}
                    opacity={s.opacity}
                    offsetX={s.width / 2}
                    offsetY={s.height / 2}
                    scaleX={s.scaleX * (s.flipX ? -1 : 1)}
                    scaleY={s.scaleY * (s.flipY ? -1 : 1)}
                    draggable
                    onClick={() => setSelectedId(s.id)}
                    onTap={() => setSelectedId(s.id)}
                    onDragEnd={(e)=> onDragEnd(s.id, e)}
                    onTransformEnd={(e)=> onTransformEnd(s.id, e)}
                  />
                );
              }
            })}

            <Transformer ref={transformerRef} rotateEnabled={true} />
          </Layer>
        </Stage>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
